/* C code for program ipSNCServer, generated by snc from ../ipSNCServer.st */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 5 "../ipSNCServer.st"
#include <string.h>
# line 6 "../ipSNCServer.st"
#include <epicsString.h>
# line 7 "../ipSNCServer.st"
#include <epicsEvent.h>
# line 8 "../ipSNCServer.st"
#include <asynDriver.h>
# line 9 "../ipSNCServer.st"
#include <asynOctet.h>
# line 10 "../ipSNCServer.st"
#include <asynOctetSyncIO.h>
# line 27 "../ipSNCServer.st"
static void initialize(SS_ID ssId, struct UserVar *pVar);
# line 28 "../ipSNCServer.st"
static int readSocket(SS_ID ssId, struct UserVar *pVar);
# line 29 "../ipSNCServer.st"
static int writeSocket(SS_ID ssId, struct UserVar *pVar);

/* Variable declarations */
struct seqg_vars {
# line 14 "../ipSNCServer.st"
	string input;
# line 15 "../ipSNCServer.st"
	string output;
# line 16 "../ipSNCServer.st"
	int connected;
# line 18 "../ipSNCServer.st"
	char *listenerPortName;
# line 19 "../ipSNCServer.st"
	char *IOPortName;
# line 20 "../ipSNCServer.st"
	int readStatus;
# line 21 "../ipSNCServer.st"
	int writeStatus;
# line 22 "../ipSNCServer.st"
	char *pasynUser;
# line 23 "../ipSNCServer.st"
	char *registrarPvt;
# line 24 "../ipSNCServer.st"
	char *eventId;
};


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
}

/****** Code for state "init" in state set "ipSNCServer" ******/

/* Event function for state "init" in state set "ipSNCServer" */
static seqBool seqg_event_ipSNCServer_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "ipSNCServer" */
static void seqg_action_ipSNCServer_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 35 "../ipSNCServer.st"
			seqg_var->listenerPortName = seq_macValueGet(seqg_env, "PORT");
			initialize(ssId, pVar);
# line 37 "../ipSNCServer.st"
			seqg_var->connected = 0;
		}
		return;
	}
}

/****** Code for state "waitConnect" in state set "ipSNCServer" ******/

/* Event function for state "waitConnect" in state set "ipSNCServer" */
static seqBool seqg_event_ipSNCServer_0_waitConnect(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "waitConnect" in state set "ipSNCServer" */
static void seqg_action_ipSNCServer_0_waitConnect(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 43 "../ipSNCServer.st"
			seq_pvPutTmo(seqg_env, 2/*connected*/, DEFAULT, DEFAULT_TIMEOUT);
			epicsEventWait( (epicsEventId)pVar->eventId);
# line 45 "../ipSNCServer.st"
			seq_pvPutTmo(seqg_env, 2/*connected*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "processCommands" in state set "ipSNCServer" ******/

/* Event function for state "processCommands" in state set "ipSNCServer" */
static seqBool seqg_event_ipSNCServer_0_processCommands(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 50 "../ipSNCServer.st"
	if (seqg_var->connected)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 62 "../ipSNCServer.st"
	if (!seqg_var->connected)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "processCommands" in state set "ipSNCServer" */
static void seqg_action_ipSNCServer_0_processCommands(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
			/* C code definitions */
# line 51 "../ipSNCServer.st"
			pVar->readStatus = readSocket(ssId, pVar);
# line 52 "../ipSNCServer.st"
			if (seqg_var->readStatus == 0)
			{
# line 53 "../ipSNCServer.st"
				seq_pvPutTmo(seqg_env, 0/*input*/, DEFAULT, DEFAULT_TIMEOUT);
# line 54 "../ipSNCServer.st"
				strcpy(seqg_var->output, "OK");
				pVar->writeStatus = writeSocket(ssId, pVar);
# line 56 "../ipSNCServer.st"
				if (seqg_var->writeStatus == 0)
				{
# line 57 "../ipSNCServer.st"
					seq_pvPutTmo(seqg_env, 1/*output*/, DEFAULT, DEFAULT_TIMEOUT);
				}
			}
		}
		return;
	case 1:
		{
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"{P}stringInput", offsetof(struct seqg_vars, input), "input", P_STRING, 1, 1, 0, 0, 0, 0},
	{"{P}stringOutput", offsetof(struct seqg_vars, output), "output", P_STRING, 1, 2, 0, 0, 0, 0},
	{"{P}connected", offsetof(struct seqg_vars, connected), "connected", P_INT, 1, 3, 0, 0, 0, 0},
};

/* Event masks for state set "ipSNCServer" */
static const seqMask seqg_mask_ipSNCServer_0_init[] = {
	0x00000000,
};
static const seqMask seqg_mask_ipSNCServer_0_waitConnect[] = {
	0x00000000,
};
static const seqMask seqg_mask_ipSNCServer_0_processCommands[] = {
	0x00000008,
};

/* State table for state set "ipSNCServer" */
static seqState seqg_states_ipSNCServer[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_ipSNCServer_0_init,
	/* event function */    seqg_event_ipSNCServer_0_init,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ipSNCServer_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "waitConnect",
	/* action function */   seqg_action_ipSNCServer_0_waitConnect,
	/* event function */    seqg_event_ipSNCServer_0_waitConnect,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ipSNCServer_0_waitConnect,
	/* state options */     (0)
	},
	{
	/* state name */        "processCommands",
	/* action function */   seqg_action_ipSNCServer_0_processCommands,
	/* event function */    seqg_event_ipSNCServer_0_processCommands,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_ipSNCServer_0_processCommands,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "ipSNCServer",
	/* states */            seqg_states_ipSNCServer,
	/* number of states */  3
	},
};

/* Program table (global) */
seqProgram ipSNCServer = {
	/* magic number */      2002008,
	/* program name */      "ipSNCServer",
	/* channels */          seqg_chans,
	/* num. channels */     3,
	/* state sets */        seqg_statesets,
	/* num. state sets */   1,
	/* user var size */     sizeof(struct seqg_vars),
	/* param */             "P=testIPServer:=, PORT=P5000",
	/* num. event flags */  0,
	/* encoded options */   (0 | OPT_CONN | OPT_NEWEF | OPT_REENT),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};
# line 68 "../ipSNCServer.st"

static void connectionCallback(void *drvPvt, asynUser *pasynUserIn, char *portName, size_t len, int eomReason)
{
    struct UserVar *pVar = (struct UserVar *)drvPvt;
    asynUser *pasynUser;
    asynStatus status;

    pVar->IOPortName = epicsStrDup(portName);
    status = pasynOctetSyncIO->connect(portName, 0, &pasynUser, NULL);
    pVar->pasynUser = (char *)pasynUser;
    asynPrint(pasynUser, ASYN_TRACE_FLOW,
              "ipSNCServer: connectionCallback, portName=%s\n", portName);
    if (status) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "ipSNCServer:connectionCallback: unable to connect to port %s\n",
                  portName);
        return;
    }
    status = pasynOctetSyncIO->setInputEos(pasynUser, "\r\n", 2);
    if (status) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "ipSNCServer:connectionCallback: unable to set input EOS on %s: %s\n",
                  portName, pasynUser->errorMessage);
        return;
    }
    status = pasynOctetSyncIO->setOutputEos(pasynUser, "\r\n", 2);
    if (status) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "ipSNCServer:connectionCallback: unable to set output EOS on %s: %s\n",
                  portName, pasynUser->errorMessage);
        return;
    }

    pVar->connected = 1;
    epicsEventSignal( (epicsEventId)pVar->eventId);
}

static void initialize(SS_ID ssId, struct UserVar *pVar)
{
    int addr=0;
    asynInterface *pasynInterface;
    asynUser *pasynUser;
    asynOctet *pasynOctet;
    void *registrarPvt;
    int status;

    pVar->eventId = (char *)epicsEventCreate(epicsEventEmpty);
    pasynUser = pasynManager->createAsynUser(0,0);
    pVar->pasynUser = (char *)pasynUser;
    pasynUser->userPvt = pVar;
    status = pasynManager->connectDevice(pasynUser, pVar->listenerPortName, addr);
    if(status!=asynSuccess) {
        printf("can't connect to port %s: %s\n", pVar->listenerPortName, pasynUser->errorMessage);
        return;
    }
    pasynInterface = pasynManager->findInterface(pasynUser,asynOctetType,1);
    if(!pasynInterface) {
        printf("%s driver not supported\n",asynOctetType);
        return;
    }
    pasynOctet = (asynOctet *)pasynInterface->pinterface;
    status = pasynOctet->registerInterruptUser(
                 pasynInterface->drvPvt, pasynUser,
                 connectionCallback,pVar, &registrarPvt);
    pVar->registrarPvt = registrarPvt;
    if(status!=asynSuccess) {
        printf("ipSNCServer devAsynOctet registerInterruptUser %s\n",
               pasynUser->errorMessage);
    }
}

static int readSocket(SS_ID ssId, struct UserVar *pVar)
{
    char buffer[80];
    size_t nread;
    int eomReason;
    asynUser *pasynUser = (asynUser *)pVar->pasynUser;
    asynStatus status;

    status = pasynOctetSyncIO->read(pasynUser, buffer, 80,
                                    -1.0, &nread, &eomReason);
    if (status) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "ipSNCServer:readSocket: read error on: %s: %s\n",
                  pVar->IOPortName, pasynUser->errorMessage);
        pVar->connected = 0;
        strcpy(pVar->input, "");
    }
    else {
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "ipSNCServer:readSocket: %s read %s\n",
                   pVar->IOPortName, buffer);
        strcpy(pVar->input, buffer);
    }
    return(status);
}

static int writeSocket(SS_ID ssId, struct UserVar *pVar)
{
    size_t nwrite;
    asynUser *pasynUser = (asynUser *)pVar->pasynUser;
    asynStatus status;

    status = pasynOctetSyncIO->write(pasynUser, pVar->output, strlen(pVar->output),
                                     0.0, &nwrite);
    if (status) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "ipSNCServer:writeSocket: write error on: %s: %s\n",
                  pVar->IOPortName, pasynUser->errorMessage);
        pVar->connected = 0;
    }
    else {
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                   "ipSNCServer:writeSocket: %s write %s\n",
                   pVar->IOPortName, pVar->output);
    }
    return(status);
}



/* Register sequencer commands and program */
#include "epicsExport.h"
static void ipSNCServerRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&ipSNCServer);
}
epicsExportRegistrar(ipSNCServerRegistrar);
